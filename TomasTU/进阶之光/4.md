# 多线程编程

## 线程基础

### 线程和进程的区别
  - 进程：系统进行资源分配和调度的基本单位（可看作是程序的实体，受操作系统管理的基本运行单元）；线程的容器
  - 线程：操作系统调度的最小单位；一个进程中可以创建多个线程，其拥有各自独立的计数器、堆栈和局部变量等属性，并能够访问共享的内存变量

### 为何需要多线程
  - 减少程序响应时间，防止耗时操作堵塞主线程造成程序无响应（ANR）
  - 线程的创建和切换开销相比进程而言更小，并且在数据共享方面效率更高
  - 多核设备具备执行多线程能力，可以提高CPU利用率
  - 简化程序结构，便于理解和维护

### 线程的创建
1. **继承Thread类，重写`run()`**  -> 只有当需要实现Thread类中的其他方法时才使用
   - 创建Thread子类的对象
   - 调用子类对象的start()启动线程
2. **实现Runnable接口和其中的`run()`** -> 推荐使用
   - 创建实现Runnable接口的对象
   - 创建Thread实例，并将Runnable对象作为参数传入构造函数中
   - 调用Thread实例的start()
3. **实现Callable接口和其中的`call()`** -> 不常用
   - 创建实现Call接口的对象
   - 创建ExecutorService变量，使用Executors.newSingleThreadPool()赋值
   - 通过ExecutorService变量的submit(Callable)，获取Future，并保存在变量中
   - 调用Future变量的get()，获取运行结果返回值

> Callable是属于Executor框架下的功能类，它提供了比Runnable更强大的功能
> 
> 1. Callable可以在任务接受后提供一个返回值
> 2. `call()`方法可以抛出异常
> 3. 运行Callable可以拿到一个Future对象，其表示异步计算的结果，提供了检查计算是否完成的方法。由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下就可以使用Future来监视目标线程调用call()的情况。但调用get()以获取结果时，当前线程就会被阻塞，直到call()返回结果。


### 线程的状态 (Java线程)

- New：新创建状态。线程被创建，还未调用`start()`
- Runnable：可运行状态。当调用`start()`后便处于Runnable。但是是否正在运行，取决于操作系统是否分配时间片给线程
- Blocked：阻塞状态。
- Waiting：等待状态。线程不活动，不运行任何代码，直至线程调度器再次调用。此时消耗资源最少
- Time waiting：超时等待状态。可以在指定的时间自行返回
- Terminated：终止状态。表示当前线程执行完毕，可能是正常执行结束，也可能是没有捕获异常而终止

![image：线程状态模型图](C:\\Users\\tuwei\\Downloads\\thread-states.png)

> blocked 状态指的是进行系统调用，通过操作系统挂起线程后，线程的状态；而 waiting 状态则不需要进行系统调用，是一种 JVM 层面的线程阻塞后的状态。由于转换到 blocked 状态需要进行系统调用，所以到这个状态的转换操作比较重。

### 中断
线程终止的方法有很多种
1. `run()`执行完毕，线程自动终止
2. 出现了没有被捕获的异常
3. ~~(Deprecated) 调用`stop()`~~
4. 调用`interrupt()` -> 将线程的**中断标识位**设为true

其中**第四种方式**是**通过中断达到终止线程的效果**

> 需要注意：被中断的线程不一定会终止，中断线程是为了引起线程的注意，被中断的线程可以决定如何去响应中断：如果是比较重要的线程，则可以不用理会中断；而大部分情况下，线程会将中断作为一个终止的请求。
>
> 也就是说，**调用`interrupt()`并不一定会导致线程终止**。
  
线程在运行过程中，会时常检测中断标识位的值，以判断自己是否应该被中断。我们也可以使用`Thread.currentThread().isInterrupted()`手动判断线程的中断标识位是否被置位 *（也就是标志为true）* 。同样的，我们还可以使用`Thread.interrupted()`将中断标识位进行复位 *（将标志修改为false）*。

但是当线程被阻塞，它是无法检测自己的中断状态的。而如果当线程处于阻塞状态时，那么线程在检查中断标识位时若发现标志位为true，则会在阻塞方法调用出抛出`InterruptedException`，并且在抛出异常前将线程的中断标识位复位。

对于`InterruptedException`有两种建议的处理方式：
1. 在catch中调用`Thread.currentThread.interrupt()`设置中断标志位，让外界通过`Thread.currentThread().isInterrupted()`决定是否终止线程
2. 不使用try-catch，而是让方法把异常抛出，让调用者处理

### 安全的终止线程
尝试一下使用中断来终止线程
```java
public class StopThread {
    public static void main(String[] args) throws InterruptedException {
        MoonRunner runnable = new MoonRunner();
        Thread thread = new Thread(runnable, "MoonThread");
        thread.start();
        // 使主线程睡眠10ms，给MoonThread线程时间来感知中断，从而结束进程
        TimeUnit.MILLISECONDS.sleep(10);  
        thread.interrupt();
    }
    public static class MoonRunner implements Runnable {
        private long i;

        @Override
        public void run() {
            while (!Thread.currentThread().isInterrupted()) {
                i++;
                System.out.println("i = " + i);
            }
            System.out.println("stop");
        }
    }
}
```

除了中断，我们还可以采用boolean变量来控制是否需要停止线程 *（其实就是模仿Thread的中断标识位）*
```java
public class StopThread2 {
    public static void main(String[] args) throws InterruptedException {
        MoonRunner runnable = new MoonRunner();
        Thread thread = new Thread(runnable, "MoonThread");
        thread.start();
        TimeUnit.MILLISECONDS.sleep(10);
        runnable.cancel();
    }

    public static class MoonRunner implements Runnable {
        private long i;
        // 使用volatile关键字，它涉及多个线程对变量的访问
        // 当有线程改变其的值时，所有的线程都可以感知到他的变化
        // Thread中的中断标志位也使用了该关键字
        volatile boolean on = true;

        @Override
        public void run() {
            while (on) {
                i++;
                System.out.println("i=" + i);
            }
            System.out.println("stop");

        }

        public void cancel() {
            on = false;
        }
    }
}
```

## 线程同步
在多线程中，如果两个或以上的线程存取相同的对象，并且每一个线程都调用了修改该对象的方法，这个情况通常被称为**竞争条件**。

在共用同一个资源时，如果不使用同步，将无法保证其原子性。如果将资源加锁，当一个线程使用完资源后，再把锁给另一个要使用这个资源的线程，这样就可以避免数据不同步的情况。

### 重入锁与条件对象
synchronized关键字提供了锁以及相关的条件。大多数需要显式锁的情况，使用synchronized比较方便。除此之外，还有一种**重入锁**，它允许一个线程对资源的重复加锁（也就是**重进入**）
 ```java
 Lock mLock = new ReentrantLock();
 mLock.lock();
 
 try {
   ...
 } 
 finally {
   mLock.unlock();
 }
 ```

 重入锁确保任何时刻只有一个线程进入临界区（同一时刻只能有一个任务访问的代码区）。一旦线程对锁对象上锁，其他线程都将无法进入Lock语句。如果在临界区发生了异常，锁是必须要释放的，否则其他线程将会永远被阻塞。
 
 进入临界区时，却发现在某一个条件满足之后，它才能执行。这时可以使用一个条件对象（条件变量）来管理那些以及获得一把锁但是却不能做有用工作的线程。使用方法如下：
1. 首先在处理资源的类中添加重入锁对象(ReentrantLock)和条件对象(Condition，可根据需要使用重入锁调用newCondition()获取多个)
2. 在对资源进行处理的类方法中，调用ReentrantLock实例的lock()，为资源上锁
3. 当处理资源时遇到因为不满足处理要求的情况时，调用条件对象的await()，暂时堵塞当前线程并放弃锁
4. 如果在await()后某一时刻又达到了处理要求，可以再调用条件对象的signalAll()，以激活因为这个条件对象导致阻塞的所有进程

```java
public class Alipay {
    private Lock alipaylock;
    private double[] accounts;
    private Condition condition;

    public Alipay(int n, double money) {
        accounts = new double[n];
        alipaylock = new ReentrantLock();
        condition = alipaylock.newCondition();
        Arrays.fill(accounts, money);
    }

    public void transfer(int from, int to, int amount) throws InterruptedException {
        alipaylock.lock();
        try {
            while (accounts[from] < amount) {
                System.out.println(Thread.currentThread().getName());
                System.out.println("TRANSFER: doesn't meet the condition, call condition.await()");
                condition.await();
            }
            System.out.println(Thread.currentThread().getName());
            System.out.println("TRANSFER: meet the condition, do transfer");
            accounts[from] = accounts[from] - amount;
            accounts[to] = accounts[to] + amount;
            condition.signalAll();
        } finally {
            alipaylock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Alipay alipay = new Alipay(3, 100);
        System.out.println("MAIN: start transfer");

        Thread stepOne = new Thread(() -> {
            try {
                alipay.transfer(1, 0, 110);
            } catch (InterruptedException ignored) {}
        }, "STEPONE");
        System.out.println("MAIN: start STPEONE thread");
        stepOne.start();

        TimeUnit.MILLISECONDS.sleep(1000);

        Thread stepTwo = new Thread(() -> {
            try {
                alipay.transfer(2, 1, 10);
            } catch (InterruptedException ignored) {}
        }, "STEPTWO");
        System.out.println("MAIN: start STPETWO thread");
        stepTwo.start();

        TimeUnit.MILLISECONDS.sleep(1000);
        TimeUnit.MILLISECONDS.sleep(1000);
    }
}
```
> 注意：
> 
> 1. 拥有锁的所有权才能使用`signalAll()` / `signal()`方法
> 2. 调用`signalAll()`并不是立即激活一个等待线程，它仅仅解除了等待线程的阻塞，以便这些线程能够在当前线程退出同步方法后，通过竞争实现对对象的访问
> 3. `signal()`是随机解除某个线程的阻塞。如果该线程仍然不能运行，则再次被阻塞。如果没有其他线程再次调用`signal()`，那么系统就死锁了

### 同步方法
Lock接口和Condition接口提供了高度的锁定控制。但大多数时候提供简单的控制即可。从Java1.0开始，所有对象都有一个内部锁。如果一个方法使用synchronized关键字声明，那么对象的锁将保护整个方法（要调用方法就必须获得内部的对象锁）

例如上方的例子可改写为
```java
public synchronized void transfer(int from, int to, int amount) throws InterruptedException {
   while (accounts[from] < amount) {
      wait();
   }
   accounts[from] = accounts[from] - amount;
   accounts[to] = accounts[to] + amount;
   notifyAll();
}
```
> 注意：
> 1. 使用同步方法必须要意识到每一个对象有一个内部锁，并且该锁有一个内部条件。由该锁来管理那些试图进入synchronized方法的线程，由该锁中的条件来管理那些调用wait()线程。
> 2. 个人实践中发现：如果要对synchronized方法使用notify() / notifyAll()，必须保证对同一个内部锁进行操作。因为在类成员synchronized方法内调用时，内部锁的对象都是该成员自身(this)

### 同步代码块
除了前一块提到的synchronized方法，还可以使用同步代码块(synchronized block)。不过同步代码比较脆弱，一般不推荐使用。如果需要实现同步，最好使用java.util.concurrent下的类（比如阻塞队列）。
```java
public class Alipay {
    private Object lock;
    private double[] accounts;

    public Alipay(int n, double money) {
        accounts = new double[n];
        lock = new ReentrantLock();
        Arrays.fill(accounts, money);
    }

    public void transfer(int from, int to, int amount) throws InterruptedException {
        synchronized (lock) {
            accounts[from] = accounts[from] - amount;
            accounts[to] = accounts[to] + amount;
        }
    }
}
```

如果同步方法适合你的程序，请尽量使用同步方法，它可以减少代码数量，避免出错；如果特别需要使用Lock/Condition结构提供的独有特性时，才使用它。

### Java内存模型
- 内存模型是抽象概念，涵盖了缓存、写缓存区、寄存器等区域。它定义了线程和主存之间的抽象关系：线程之间的共享变量存储在主存中，每一个线程都有一个私有的本地内存，本地内存中存储了该线程共享的变量的副本。
- 堆内存是运行时的内存区域，用于存储对象实例，并被所有线程共享；但是局部变量、方法定义的参数则不会在线程之间共
- Java内存模型控制线程之间的通信，决定一个线程对主存共享变量的写入何时对另一个线程可见

### 并发编程的特性
1. 原子性
   
   对基本数据类型变量的读取和赋值操作是原子性操作：不可被中断。要么就执行完毕，要么就不执行。`java.util.concurrent.atomic`包中有很多类使用了很高效的机器指令（而不是使用锁）来保证其他操作的原子性。

2. 可见性
   
    可见性是指“线程之间的可见性”。一个线程修改的状态对另一个线程是可见的。也就是说，一个线程修改的结果，另一个线程马上就能看到。


3. 有序性

    Java内存模型中允许编译器和处理器对指令进行重排序。虽然重排序的过程不会影响单线程执行的正确性，但是会影响到多线程并发执行的正确性。

### volatile
volatile可以为实例域的同步访问提供免锁的机制。如果一个域为volatile，那么编译器和JVM就知道该域是可能被另一个线程并发更新的。当变量使用volatile关键字后，修改的值会立即被更新到主存，对其他线程是可见的；同时，禁止编译器对其指令进行重排序，也就是在volatile之前的操作已经全部执行完毕，并且结果对后面的操作可见，保证线程可以顺序执行同步代码。但是volatile不能保证原子性。

#### 正确使用volatile
使用volatile必须具备两个条件：(1)对变量的写操作不会依赖当前值。(2)该变量没有包含在具有其他变量的不变式中。

在实际开发中，有两种常见的volatile使用场景：
1. 状态标志
    ```java
    volatile boolean shutdownRequested;
    ...
    public void shutdown() {
      shutdownRequested = true;
    }
    public void doWork() {
      while(!shutdownRequested) {
        ...
      }
    }
   ```
2. 双重检查模式(DCL)
    ```java
    public class Singlenton {
      private volatile static Singleton instance = null
      public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance
      }
    }
    ```

 ## 阻塞队列

 常用于生产者和消费者场景。阻塞队列(BlockingQueue)就是生产者存放元素的容器，而消费者也只从容器里拿元素。当队满或队空时，都会使得其中一方自动阻塞，直到队列有空或有数据是则自动唤醒。

其中的一些核心方法：

放入元素
- offer(anObject)
- offer(E o, long timeout, TimeUnit unit)
- put(anObject)
- 
获取数据
- poll(long timeout, TimeUnit unit)
- take()
- drainTo()

### Java中的阻塞队列
- ArrayBlockingQueue
- LinkedBlockingQueue
- PriorityBlockingQueue
- DelayQueue
- SynchronousQueue
- LinkedTransferQueue
- LinkedBlockingQeque
