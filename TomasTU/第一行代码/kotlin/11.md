# 使用协程编写高效的并发程序

## 基本用法
1. 引入标准库
```groovy
dependencies {
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.1.1'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1'
}
```
2. 开启一个协程 / 创建协程作用域

|方法|介绍|
|-----|-----|
|`GlobalScope.launch()`|创建顶层协程，当应用程序结束时，该协程也会一起结束|
|`runBlocking()`|创建协程作用域，保证在协程作用域内的所有代码和子协程没有全部执行完之前一直阻塞当前**线程**。（正式环境中容易产生性能问题）|
|`coroutineScope()`|挂起函数，可以在任何其他挂起函数中调用。继承外部的协程作用域，并创建一个子作用域。（用于给任意挂起函数提供协程作用域）<br/>类似于runBlocking()，它会保证其作用域内的所有代码和子协程在全部执行完之前，会一直阻塞当前**协程**|
|`launch()`|开启一个协程（需要在协程作用域中，创建子协程）|
|`suspend` 关键字|**声明**在当前函数中存在协程作用域，也就是将函数声明为**挂起函数**|
> `delay()` -> 指定当前协程延迟指定时间后再运行。非阻塞式挂起函数，只会挂起当前协程，不影响其他协程。

## 更多的作用域构建器
不论是`GlobalScope.launch()`还是`launch()`，都会返回`Job`对象。只要使用Job对象的`cancel()`方法就可以取消协程。

创建一个Job对象，将它传入`CoroutineScope()`。函数会返回一个`CoroutineScope`对象，之后便可以通过调用其`launch()`函数创建协程。所有调用CoroutineScope的launch()所创建的协程，都会被关联在Job对象的作用域下面。所以只需要调用一次`cancel()`，就可以将同一作用域的所有协程全部取消。

`launch()`函数只能开启一个协程并返回`Job`对象，而如果需要创建协程并获取执行结果，可以使用`async`函数，但是必须在协程作用域当中才能调用。它会创建一个新的子协程并返回一个`Deferred`对象。如果需要获取执行结果，只需要调用Deferred对象的`await()`方法。

在调用`await()`方法后，代码块中的代码就会立即开始执行。如果代码块中的代码还没有执行完，**当前协程**就会被阻塞住，知道可以获得`async`函数的执行结果

### withContext()
一个特殊的挂起函数，可以理解成async函数的简化版写法